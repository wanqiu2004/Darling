## JAR 文件规范

内容
- 简介
- META-INF 目录
- 名称-值对和部分
- JAR 清单文件
  - 概述
  - 清单文件规范
  - 主属性
  - 每条目属性
- 签名的 JAR 文件
  - 概述
  - 签名文件
  - 签名验证
  - 魔法属性
  - 数字签名
  - 关于清单和签名文件的说明
- JAR 索引
  - 概述
  - 索引文件规范
  - 向后兼容性
- 服务提供者
  - 概述
  - 提供者配置文件
  - 示例
- Class-Path 属性
- 包密封
- API 细节
- 参见

### 简介


本质上，JAR 文件就是一个包含可选的 META-INF 目录的 ZIP 文件。
可以通过命令行 jar 工具或使用 Java 平台中的 java.util.jar API 创建 JAR 文件。
对于 JAR 文件的名字没有限制，它可以是特定平台上的任何合法文件名。
在很多情况下，JAR 文件不仅仅是简单的 Java 类文件和/或资源的存档。
它们被用作应用程序和扩展的基础构建块。
如果存在的话，META-INF 目录用于存储包和扩展配置数据，包括安全、版本控制、扩展和服务等信息。


### META-INF 目录


在 META-INF 目录中的以下文件或目录被 Java 平台识别并解释，用于配置应用程序、扩展、类加载器和服务：
- MANIFEST.MF：这是用于定义扩展和包相关数据的清单文件。
- INDEX.LIST：该文件由 jar 工具的新 "-i" 选项生成，包含应用程序或扩展中定义的包的位置信息。它是 JarIndex 实现的一部分，用于类加载器以加快其类加载过程。
- x.SF：JAR 文件的签名文件，这里的 'x' 代表基础文件名。
- x.DSA：与具有相同基础文件名的签名文件关联的签名块文件。此文件存储相应签名文件的数字签名。
- services/：此目录存储所有的服务提供者配置文件。


### 一些格式约定


大多数情况下，清单文件和签名文件中包含的信息表示为“名称: 值”对，我们也把这些对称作头部或属性。
一组对称为一个“部分”。各部分通过空行分隔开。

任何形式的二进制数据都以 base64 表示。如果导致行长度超过 72 字节，则需要对二进制数据进行续行。二进制数据的例子包括摘要和签名。

实现应支持高达 65535 字节的头部值。


规范如下：
- 部分: 由 * 头部 + 换行符组成
- 非空部分: 至少一个头部 + 换行符
- 换行符: CR LF | LF | CR（不跟随 LF）
- 头部: 名称 : 值
- 名称: alphanum * 头部字符
- 值: 空格 * 其他字符 换行符 * 续行
- 续行: 空格 * 其他字符 换行符
- alphanum: {A-Z} | {a-z} | {0-9}
- 头部字符: alphanum | - | _
- 其他字符: 除了 NUL、CR 和 LF 之外的任何 UTF-8 字符

注意：为了避免通过直接电子邮件发送文件时造成文件损坏，没有头部会以字母 "From" 开头。

上述规范中定义的非终端符号将在接下来的规范中引用。


### MANIFEST.MF 清单文件


清单由一个主部分与针对 JAR 文件各个条目的部分列表组成，


**主部分**包含了关于 JAR 文件本身的安全和配置信息，以及该 JAR 文件所属的应用程序或扩展的信息。它还定义了适用于每个单独清单条目的主要属性。


**单独的部分**必须以名为 "Name" 的属性开始，为这个 JAR 文件中包含的包或文件定义各种属性。并不是 JAR 文件中的所有文件都需要在清单中作为条目列出，但是要签名的所有文件都必须列出。清单文件本身不应被列出。每个部分，其值必须是文件的相对路径，或者是一个引用归档外数据的绝对 URL。

如果某个属性在不同部分中有不同的值，则以最后一个为准。不被理解的自定义属性将被忽略

如何组织和编写清单文件：
由一个主部分和0个或多个单独部分组成
主部分:包含了版本信息和一些主要属性。
单独部分:针对JAR文件中具体条目的部分

出现在主部分中的属性称为主属性，而出现在单独部分中的属性称为每条目属性。
某些属性既可以出现在主部分也可以出现在单独部分，在这种情况下，每条目属性值会覆盖主属性值。


**主属性**

通用主属性
- **Manifest-Version**：清单文件的版本。其值是一个合法的版本号。
- **Created-By**：定义了生成此清单文件所基于的 Java 实现的版本和供应商。此属性由 jar 工具生成。
- **Signature-Version**：定义了 JAR 文件的签名版本。
- **Class-Path**：此属性的值指定了jar包依赖的jar的相对 URL。URL 之间用一个或多个空格分隔。

创建可执行 JAR 文件使用的属性
- **Main-Class**：此属性的值是启动时加载程序的主要应用程序类的类名。类名不应附加 .class 扩展名。

用于扩展识别的属性
- **Extension-Name**：此属性为 JAR 文件中包含的扩展指定一个名称。名称应为唯一的标识符，例如组成扩展的主要包的名称。

用于扩展和包版本控制及密封信息的属性
- **Implementation-Title**：值是一个字符串，定义了扩展实现的标题。
- **Implementation-Version**：值是一个字符串，定义了扩展实现的版本。
- **Implementation-Vendor**：值是一个字符串，定义了维护扩展实现的组织。
- **Specification-Title**：值是一个字符串，定义了扩展规范的标题。
- **Specification-Version**：值是一个字符串，定义了扩展规范的版本。
- **Specification-Vendor**：值是一个字符串，定义了维护扩展规范的组织。
- **Sealed**：此属性定义了此 JAR 文件是否被密封。值可以是 "true" 或 "false"，不区分大小写。如果设置为 "true"，则默认情况下 JAR 文件中的所有包都被密封，除非个别地另行定义。


**每条目属性**


每条目属性仅适用于与清单条目关联的单个 JAR 文件条目。如果相同的属性也出现在主部分中，则每条目属性的值将覆盖主属性的值。例如，如果 JAR 文件 a.jar 有如下清单内容：
```
Manifest-Version: 1.0
Created-By: 1.2 (Sun Microsystems Inc.)
Sealed: true
Name: foo/bar/
Sealed: false
```
这意味着 a.jar 中存档的所有包都是密封的，除了 foo.bar 包不密封。

每条目属性可以分为以下几组：

文件内容定义的属性


- **Content-Type**：此属性可用于指定 JAR 文件中特定文件条目的数据 MIME 类型和子类型。值应为 type/subtype 形式的字符串。例如，“image/bmp”是一种图像类型，其子类型为 bmp（表示位图）。这表明文件条目是一个以位图格式存储数据的图像。RFC 1521 和 1522 讨论并定义了 MIME 类型。


包版本控制和密封信息定义的属性


这些是在上面作为主属性定义的同一组属性，用于定义扩展包的版本控制和密封信息。当用作每条目属性时，这些属性会覆盖主属性，但仅适用于清单条目指定的单独文件。


为 Beans 对象定义的属性


- **Java-Bean**：定义特定 JAR 文件条目是否为 Java Beans 对象。值应为 “true” 或 “false”，不区分大小写。

签名定义的属性


这些属性用于签名和验证目的。
- **x-Digest-y**：此属性名称指定了用于计算对应 JAR 文件条目的摘要值的摘要算法名称。该属性的值存储实际的摘要值。前缀 'x' 指定算法名称，可选后缀 'y' 表示摘要值应该针对哪种语言进行验证。
- **Magic**：这是一个可选属性，应用程序可以用它来指示验证程序如何计算清单条目中包含的摘要值。该属性的值是一组逗号分隔的上下文特定字符串。




### 签名的 JAR 文件


JAR 文件可以通过使用命令行 jarsigner 工具或直接通过 java.security API 进行签名。
如果通过 jarsigner 工具对 JAR 文件进行签名，
那么非签名相关的文件的每个文件条目都将被签名。与签名相关的文件包括：
- META-INF/MANIFEST.MF
- META-INF/*.SF
- META-INF/*.DSA
- META-INF/*.RSA
- META-INF/SIG-*


java.security API 可以对 JAR 文件的子集进行签名。签名的 JAR 文件与原始 JAR 文件不同之处在于，
- 其清单被更新
- META-INF 目录中添加了一个签名文件
- META-INF 目录中添加了一个签名块文件。

当不使用 jarsigner 时，签名程序必须构建签名文件和签名块文件两者。

对于签名 JAR 文件中的每个被签名的文件条目，只要它在清单文件中不存在，就会为其创建一个单独部分。列出一个或多个摘要属性和一个可选的 Magic 属性。

每个对JAR文件进行签名的签名者都会有一个扩展名为.SF的签名文件。这个文件主要用于验证JAR文件的完整性和真实性。

尽管MANIFEST.MF记录了每个JAR条目的哈希值，但它自身也需要一种方式来防止篡改。如果没有.SF文件提供的额外验证步骤，攻击者可以直接修改MANIFEST.MF并重新计算哈希值，从而无法检测到对清单文件本身的篡改。.SF文件通过对MANIFEST.MF的哈希值进行签名，提供了额外的一层安全保护，确保了清单文件的不可篡改性。

此外，.SF文件支持多签名者和更高效的签名管理，这些都是仅依赖于MANIFEST.MF无法实现的功能。


### JAR索引概述

自1.3版以来，为了优化网络应用程序（尤其是小程序）类加载器的类搜索过程，引入了JarIndex。最初，小程序类加载器使用简单的线性搜索算法在其内部搜索路径上搜索每个元素，这些元素由“ARCHIVE”标签或“Class-Path”主属性构建。类加载器会下载并打开其搜索路径上的每个元素，直到找到类或资源为止。如果尝试查找不存在的资源，则必须下载应用程序或小程序中的所有JAR文件。对于大型网络应用和小程序来说，这可能导致启动缓慢、响应迟缓以及网络带宽浪费。JarIndex机制收集在小程序中定义的所有JAR文件的内容，并将信息存储在小程序类路径上的第一个JAR文件中的索引文件中。在下载第一个JAR文件后，小程序类加载器将使用收集到的内容信息有效地下载JAR文件。

现有的jar工具得到了增强，可以检查一系列JAR文件并生成目录信息，指示哪些类和资源位于哪个JAR文件中。此目录信息存储在一个名为INDEX.LIST的简单文本文件中，该文件位于根JAR文件的META-INF目录下。当类加载器加载根JAR文件时，它读取INDEX.LIST文件并用它来构造一个从文件名和包名到JAR文件名列表的映射哈希表。为了查找类或资源，类加载器查询哈希表以找到合适的JAR文件并在必要时下载它。




### 索引文件 INDEX.LIST
INDEX.LIST文件是JAR文件中用于优化类加载过程的一个重要组件，它通过预先构建一个索引来加速类加载器找到所需的类或资源。




### 服务提供者


位于`META-INF/services`目录下的文件是服务提供者配置文件。服务是一组知名的接口和（通常是抽象的）类。服务提供者是对服务的具体实现。提供者中的类通常实现这些接口并继承服务本身定义的类。服务提供者可以通过作为扩展安装在Java平台的一个实现中，即放置于任何常规扩展目录中的JAR文件。提供者也可以通过将其添加到小程序或应用程序类路径或通过其他特定于平台的方法来提供。

一个服务由一个抽象类表示。给定服务的提供者包含一个或多个扩展此服务类并带有提供者特定数据和代码的具体类。这个提供者类通常不是整个提供者本身，而是一个代理，它包含足够的信息来决定提供者是否能够满足特定请求，以及可以在需要时创建实际提供者的代码。提供者类的细节往往高度依赖于具体的服务；没有单一的类或接口可以统一它们，因此也没有定义这样的类。这里强制要求的唯一条件是提供者类必须具有零参数构造函数，以便可以在查找期间实例化它们。

**提供者配置文件**


服务提供者通过在资源目录`META-INF/services`中放置提供者配置文件来标识自己。文件名称应由抽象服务类的完全限定名组成。文件应包含一个换行符分隔的独特具体提供者类名列表。空格和制表符以及空行将被忽略。注释字符是'#'（0x23）；文件必须使用UTF-8编码。

示例


假设我们有一个名为`java.io.spi.CharCodec`的服务类，它有两个抽象方法：

```java
public abstract CharEncoder getEncoder(String encodingName);
public abstract CharDecoder getDecoder(String encodingName);
```

每个方法返回一个适当的对象或如果无法转换给定编码则返回null。典型的`CharCodec`提供者将支持不止一种编码。

如果`sun.io.StandardCodec`是`CharCodec`服务的一个提供者，那么它的JAR文件中会包含文件`META-INF/services/java.io.spi.CharCodec`。这个文件将包含一行：

```
sun.io.StandardCodec    # Standard codecs for the platform
```







### 包密封

JAR文件和包可以选择性地进行密封，以确保版本内的一致性。当一个包被密封在JAR中时，这意味着该包中的所有类必须来自同一个JAR文件。否则，将抛出`SecurityException`。

- **包密封**：在一个JAR中指定的密封包意味着该包中定义的所有类都必须源自同一个JAR。这通过清单属性`Sealed`来指定，其值为true或false（大小写不敏感）。例如：

  ```
  Name: javax/servlet/internal/
  Sealed: true
  ```

  这表示`javax.servlet.internal`包是密封的，且该包中的所有类必须从相同的JAR文件加载。

  如果缺少此属性，则使用包含JAR文件的密封属性。

- **JAR密封**：整个JAR文件也可以通过相同的清单头部`Sealed`指定为密封，值同样为true或false。例如：

  ```
  Sealed: true
  ```

  这表示除非特定包在清单条目中用`Sealed`属性明确覆盖，否则这个归档中的所有包都是密封的。

  如果缺少此属性，为了向后兼容，默认假设JAR文件不是密封的。系统随后会默认检查包头信息以获取密封信息。

包密封对于安全性也很重要，因为它限制了仅允许来自同一JAR文件的包内的类访问包保护成员。

未命名的包是不可密封的，因此希望密封的类必须放置在它们自己的包中。

### API详情

- **java.util.jar包**：提供了处理JAR文件的功能。
  
- **参考**：
  - **java.security包**：提供了一系列安全框架相关的类和接口。
  - **java.util.zip包**：支持读写标准ZIP数据格式以及读写JAR文件的数据格式。

通过使用这些API和概念，开发者可以更好地控制JAR文件的安全性和完整性，从而增强应用程序的安全性。密封包有助于防止未经授权的代码插入到已知的、受信任的包中，确保只有特定来源的类才能对这些包进行扩展或修改。
