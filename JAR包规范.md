JAR 文件规范

内容
- 简介
- META-INF 目录
- 名称-值对和部分
- JAR 清单文件
  - 概述
  - 清单文件规范
  - 主属性
  - 每条目属性
- 签名的 JAR 文件
  - 概述
  - 签名文件
  - 签名验证
  - 魔法属性
  - 数字签名
  - 关于清单和签名文件的说明
- JAR 索引
  - 概述
  - 索引文件规范
  - 向后兼容性
- 服务提供者
  - 概述
  - 提供者配置文件
  - 示例
- Class-Path 属性
- 包密封
- API 细节
- 参见

简介
JAR 文件是一种基于流行的 ZIP 文件格式，并用于将多个文件聚合为一个文件的格式。
本质上，JAR 文件就是一个包含可选的 META-INF 目录的 ZIP 文件。
可以通过命令行 jar 工具或使用 Java 平台中的 java.util.jar API 创建 JAR 文件。
对于 JAR 文件的名字没有限制，它可以是特定平台上的任何合法文件名。
在很多情况下，JAR 文件不仅仅是简单的 Java 类文件和/或资源的存档。
它们被用作应用程序和扩展的基础构建块。
如果存在的话，META-INF 目录用于存储包和扩展配置数据，包括安全、版本控制、扩展和服务等信息。


META-INF 目录
在 META-INF 目录中的以下文件或目录被 Java 2 平台识别并解释，用于配置应用程序、扩展、类加载器和服务：
- MANIFEST.MF：这是用于定义扩展和包相关数据的清单文件。
- INDEX.LIST：该文件由 jar 工具的新 "-i" 选项生成，包含应用程序或扩展中定义的包的位置信息。它是 JarIndex 实现的一部分，用于类加载器以加快其类加载过程。
- x.SF：JAR 文件的签名文件，这里的 'x' 代表基础文件名。
- x.DSA：与具有相同基础文件名的签名文件关联的签名块文件。此文件存储相应签名文件的数字签名。
- services/：此目录存储所有的服务提供者配置文件。

名称-值对和部分

在详细介绍各个配置文件的内容之前，需要定义一些格式约定。大多数情况下，清单文件和签名文件中包含的信息表示为所谓的“名称: 值”对，这受到了 RFC822 标准的启发。我们也把这些对称作头部或属性。

一组名称-值对称为一个“部分”。各部分通过空行与其他部分分隔开。

任何形式的二进制数据都以 base64 表示。如果导致行长度超过 72 字节，则需要对二进制数据进行续行。二进制数据的例子包括摘要和签名。

实现应支持高达 65535 字节的头部值。

本文件中的所有规范使用相同的语法，在这个语法中，终端符号以固定宽度字体显示，非终端符号以斜体显示。

规范如下：
- 部分: 由 * 头部 + 换行符组成
- 非空部分: 至少一个头部 + 换行符
- 换行符: CR LF | LF | CR（不跟随 LF）
- 头部: 名称 : 值
- 名称: alphanum * 头部字符
- 值: 空格 * 其他字符 换行符 * 续行
- 续行: 空格 * 其他字符 换行符
- alphanum: {A-Z} | {a-z} | {0-9}
- 头部字符: alphanum | - | _
- 其他字符: 除了 NUL、CR 和 LF 之外的任何 UTF-8 字符

注意：为了避免通过直接电子邮件发送文件时造成文件损坏，没有头部会以字母 "From" 开头。

上述规范中定义的非终端符号将在接下来的规范中引用。


JAR 清单文件

概述
一个 JAR 文件的清单由一个主部分后跟针对 JAR 文件各个条目的部分列表组成，每个部分之间用换行符分隔。主部分和单独的部分都遵循上述的部分语法。它们各自有自己的特定限制和规则。
主部分包含了关于 JAR 文件本身的安全和配置信息，以及该 JAR 文件所属的应用程序或扩展的信息。它还定义了适用于每个单独清单条目的主要属性。此部分中的任何属性名称都不能等于 "Name"。主部分以一个空行结束。

单独的部分为这个 JAR 文件中包含的包或文件定义各种属性。并不是 JAR 文件中的所有文件都需要在清单中作为条目列出，但是要签名的所有文件都必须列出。清单文件本身不应被列出。每个部分必须以名为 "Name" 的属性开始，其值必须是文件的相对路径，或者是一个引用归档外数据的绝对 URL。

如果有多个相同文件条目的单独部分，则这些部分中的属性将合并。如果某个属性在不同部分中有不同的值，则以最后一个为准。

不被理解的属性将被忽略。这些属性可能包括应用程序使用的实现特定信息。

清单规范：

manifest-file: 主部分 换行符 * 单独部分
main-section: 版本信息 换行符 * 主属性
version-info: Manifest-Version : 版本号
版本号: 数字+{.数字+}*
主属性: (任何合法的主要属性) 换行符
单独部分: Name : 值 换行符 * 每条目属性
每条目属性: (任何合法的每条目属性) 换行符
换行符: CR LF | LF | CR（不跟随 LF）
数字: {0-9}
在上面的规范中，可以出现在主部分中的属性称为主属性，而可以出现在单独部分中的属性称为每条目属性。某些属性既可以出现在主部分也可以出现在单独部分，在这种情况下，对于指定条目，每条目属性值会覆盖主属性值。这两种类型的属性定义如下：



主属性

主属性是存在于清单文件主部分中的属性，它们可以分为以下不同的组：

通用主属性
Manifest-Version：定义了清单文件的版本。其值是一个合法的版本号，如上文所述。
Created-By：定义了生成此清单文件所基于的 Java 实现的版本和供应商。此属性由 jar 工具生成。
Signature-Version：定义了 JAR 文件的签名版本。该值应为有效的版本号字符串。
Class-Path：此属性的值指定了应用程序或扩展需要的扩展或库的相对 URL。URL 之间用一个或多个空格分隔。应用程序或扩展类加载器使用此属性的值构建其内部搜索路径。详情请参阅 Class-Path 属性部分。
独立应用程序中定义的属性
这些属性用于打包到可执行 JAR 文件中的独立应用程序，可以通过运行 "java -jar x.jar" 直接调用 Java 运行时。

Main-Class：此属性的值是启动时加载程序的主要应用程序类的类名。类名不应附加 .class 扩展名。
小程序中定义的属性（已弃用）
这些属性以及实现它的机制可能在未来的版本中被移除。这些属性用于打包到 JAR 文件中的小程序，以定义小程序依赖的扩展的要求、版本和位置信息。（参见扩展版本控制）。

Extension-List：此属性指示小程序所需的扩展。在此属性中列出的每个扩展都将有一组额外的属性，小程序使用这些属性来指定所需扩展的版本和供应商。
<extension>-Extension-Name：此属性是扩展的唯一名称。Java 插件会将此属性的值与已安装扩展清单中的 Extension-Name 属性进行比较，以确定是否已安装扩展。
<extension>-Specification-Version：此属性指定小程序所需的最小扩展规范版本。Java 插件会将此属性的值与已安装扩展的 Specification-Version 属性进行比较，以确定扩展是否是最新的。
<extension>-Implementation-Version：此属性指定小程序所需的最小扩展实现版本号。Java 插件会将此属性的值与已安装扩展的 Implementation-Version 属性进行比较，以查看是否需要下载更新的实现。
<extension>-Implementation-Vendor-Id：如果小程序需要来自特定供应商的实现，则此属性可用于识别扩展实现的供应商。Java 插件会将此属性的值与已安装扩展的 Implementation-Vendor-Id 属性进行比较。
<extension>-Implementation-URL：如果所需的版本尚未安装，此属性指定一个可用于获取最新版本扩展的 URL。
用于扩展识别的属性
这些属性用于扩展以定义其唯一的身份。

Extension-Name：此属性为 JAR 文件中包含的扩展指定一个名称。名称应为唯一的标识符，例如组成扩展的主要包的名称。
用于扩展和包版本控制及密封信息的属性
这些属性定义了 JAR 文件所属扩展的功能。这些属性的值适用于 JAR 文件中的所有包，但可以被每条目属性覆盖。

Implementation-Title：值是一个字符串，定义了扩展实现的标题。
Implementation-Version：值是一个字符串，定义了扩展实现的版本。
Implementation-Vendor：值是一个字符串，定义了维护扩展实现的组织。
Implementation-Vendor-Id：已弃用，未来版本中可能会忽略此属性。值是一个唯一定义维护扩展实现的组织的字符串 ID。
Implementation-URL：已弃用，未来版本中可能会忽略此属性。此属性定义了可以从哪里下载扩展实现的 URL。
Specification-Title：值是一个字符串，定义了扩展规范的标题。
Specification-Version：值是一个字符串，定义了扩展规范的版本。
Specification-Vendor：值是一个字符串，定义了维护扩展规范的组织。
Sealed：此属性定义了此 JAR 文件是否被密封。值可以是 "true" 或 "false"，不区分大小写。如果设置为 "true"，则默认情况下 JAR 文件中的所有包都被密封，除非个别地另行定义。




每条目属性

每条目属性仅适用于与清单条目关联的单个 JAR 文件条目。如果相同的属性也出现在主部分中，则每条目属性的值将覆盖主属性的值。例如，如果 JAR 文件 a.jar 有如下清单内容：
```
Manifest-Version: 1.0
Created-By: 1.2 (Sun Microsystems Inc.)
Sealed: true
Name: foo/bar/
Sealed: false
```
这意味着 a.jar 中存档的所有包都是密封的，除了 foo.bar 包不密封。

每条目属性可以分为以下几组：

### 文件内容定义的属性
- **Content-Type**：此属性可用于指定 JAR 文件中特定文件条目的数据 MIME 类型和子类型。值应为 type/subtype 形式的字符串。例如，“image/bmp”是一种图像类型，其子类型为 bmp（表示位图）。这表明文件条目是一个以位图格式存储数据的图像。RFC 1521 和 1522 讨论并定义了 MIME 类型。

### 包版本控制和密封信息定义的属性
这些是在上面作为主属性定义的同一组属性，用于定义扩展包的版本控制和密封信息。当用作每条目属性时，这些属性会覆盖主属性，但仅适用于清单条目指定的单独文件。

### 为 Beans 对象定义的属性
- **Java-Bean**：定义特定 JAR 文件条目是否为 Java Beans 对象。值应为 “true” 或 “false”，不区分大小写。

### 签名定义的属性
这些属性用于签名和验证目的。更多详情参见相关部分。
- **x-Digest-y**：此属性名称指定了用于计算对应 JAR 文件条目的摘要值的摘要算法名称。该属性的值存储实际的摘要值。前缀 'x' 指定算法名称，可选后缀 'y' 表示摘要值应该针对哪种语言进行验证。
- **Magic**：这是一个可选属性，应用程序可以用它来指示验证程序如何计算清单条目中包含的摘要值。该属性的值是一组逗号分隔的上下文特定字符串。详细描述见此处。

通过上述分类，每条目属性提供了更精细的控制，允许开发者对 JAR 文件中的每个条目设置特定的配置或元数据，从而增强灵活性和功能性。







签名的 JAR 文件

### 概述
JAR 文件可以通过使用命令行 jarsigner 工具或直接通过 java.security API 进行签名。如果通过 jarsigner 工具对 JAR 文件进行签名，那么包括 META-INF 目录中非签名相关的文件在内的每个文件条目都将被签名。与签名相关的文件包括：
- META-INF/MANIFEST.MF
- META-INF/*.SF
- META-INF/*.DSA
- META-INF/*.RSA
- META-INF/SIG-*

请注意，如果这些文件位于 META-INF 的子目录中，则它们不被视为签名相关的。这些文件名的大小写不敏感版本是保留的，也不会被签名。

通过使用 java.security API 可以对 JAR 文件的子集进行签名。一个已签名的 JAR 文件与原始 JAR 文件完全相同，除了其清单被更新并在 META-INF 目录中添加了两个额外的文件：一个签名文件和一个签名块文件。当不使用 jarsigner 时，签名程序必须构建签名文件和签名块文件两者。

对于签名 JAR 文件中的每个被签名的文件条目，只要它在清单中不存在，就会为其创建一个单独的清单条目。每个清单条目列出一个或多个摘要属性和一个可选的 Magic 属性。

### 签名文件
每个签名者由扩展名为 .SF 的签名文件表示。该文件的主要部分类似于清单文件，包含提供者信息但不特定于任何特定的 JAR 文件条目。除了 Signature-Version 和 Created-By 属性（参见主属性），主部分还可以包括以下安全属性：
- x-Digest-Manifest-Main-Attributes（x 是 java.security.MessageDigest 算法的标准名称）: 此属性的值是对清单文件的主属性计算出的摘要值。
- x-Digest-Manifest（x 是 java.security.MessageDigest 算法的标准名称）: 此属性的值是对整个清单文件计算出的摘要值。

主部分后面跟着一个单独条目的列表，这些条目的名称也必须出现在清单文件中。每个单独条目必须至少包含其对应清单文件条目的摘要。

仅出现在清单文件而不出现在签名文件中的路径或 URL 不参与计算。

### 签名验证
若签名有效且自签名生成以来，JAR 文件中的所有文件均未更改，则 JAR 文件验证成功。JAR 文件验证涉及以下步骤：
1. 在首次解析清单文件时验证签名文件上的签名。出于效率考虑，可以记住这一验证结果。注意，这种验证仅验证签名指令本身，并不验证实际的归档文件。
2. 如果签名文件中存在 x-Digest-Manifest 属性，则将其值与对整个清单文件计算出的摘要值进行对比。如果签名文件中有多个 x-Digest-Manifest 属性，需验证至少有一个与计算出的摘要值匹配。
3. 如果签名文件中不存在 x-Digest-Manifest 属性或上一步计算出的摘要值没有一个匹配，则执行不太优化的验证：
   - 如果签名文件中存在 x-Digest-Manifest-Main-Attributes 条目，则将其值与从清单文件的主属性计算出的摘要值进行对比。如果此计算失败，则 JAR 文件验证失败。为了效率，这个决定可以被记住。如果签名文件中不存在 x-Digest-Manifest-Main-Attributes 条目，它的不存在不影响 JAR 文件验证，且不会验证清单主属性。
4. 验证签名文件中每个源文件信息部分的摘要值与从清单文件中相应条目计算出的摘要值是否一致。如果有任何一个摘要值不匹配，则 JAR 文件验证失败。

存储在 x-Digest-Manifest 属性中的清单文件的摘要值可能与当前清单文件的摘要值不等的一个原因是，在签名生成之后（因此签名文件也是），使用 jar 工具向 JAR 文件添加了一个或多个文件。使用 jar 工具添加文件时，清单文件会发生变化（为新文件添加部分），但签名文件不会改变。如果签名生成时存在于 JAR 文件中的文件自那时以来没有被更改，则仍然认为验证成功，这种情况是指签名文件的非头部部分的摘要值等于清单文件中相应部分的摘要值。

对于清单中的每个条目，验证清单文件中的摘要值与“Name:”属性所引用的实际数据（指定相对文件路径或 URL）计算出的摘要值是否一致。如果任何一个摘要值不匹配，则 JAR 文件验证失败。







示例清单文件：

```
Manifest-Version: 1.0
Created-By: 1.7.0 (Sun Microsystems Inc.)

Name: common/class1.class
SHA-256-Digest: (SHA-256摘要的base64表示)

Name: common/class2.class
SHA1-Digest: (SHA1摘要的base64表示)
SHA-256-Digest: (SHA-256摘要的base64表示)
```

对应的签名文件将是：
```
Signature-Version: 1.0
SHA-256-Digest-Manifest: (整个清单文件SHA-256摘要的base64表示)
SHA-256-Digest-Manifest-Main-Attributes: (清单主属性SHA-256摘要的base64表示)

Name: common/class1.class
SHA-256-Digest: (SHA-256摘要的base64表示)

Name: common/class2.class
SHA-256-Digest: (SHA-256摘要的base64表示)
```

### Magic 属性

验证给定清单条目的签名另一个要求是验证者理解该条目中 Magic 键值对的值。Magic 属性是可选的，但如果验证者在验证条目的签名时，需要理解条目的 Magic 键的值。

Magic 属性的值是一组逗号分隔的上下文特定字符串。逗号前后的空格将被忽略，并且不区分大小写。Magic 属性的确切含义是应用程序特定的。这些值指示如何计算清单条目中包含的哈希值，因此对于正确验证签名至关重要。关键字可用于动态或嵌入式内容、多语言文档的多个哈希等。

以下是 Magic 属性在清单文件中潜在使用的两个例子：

```
Name: http://www.example-scripts.com/index#script1
SHA-256-Digest: (SHA-256哈希的base64表示)
Magic: JavaScript, Dynamic

Name: http://www.example-tourist.com/guide.html
SHA-256-Digest: (SHA-256哈希的base64表示)
SHA-256-Digest-French: (SHA-256哈希的base64表示)
SHA-256-Digest-German: (SHA-256哈希的base64表示)
Magic: Multilingual
```

在第一个例子中，这些 Magic 值可能表明 HTTP 查询的结果是嵌入在文档中的脚本，而不是文档本身，并且该脚本是动态生成的。这两个信息指示如何计算与清单摘要值进行比较的哈希值，从而验证一个有效的签名。

在第二个例子中，Magic 值表明检索到的文档可能是为特定语言进行了内容协商，要验证的摘要取决于检索到的文档所用的语言。

### 数字签名

数字签名是 .SF 签名文件的已签名版本。这些是二进制文件，不适合人类阅读。

数字签名文件与 .SF 文件具有相同的文件名但扩展名不同。扩展名根据数字签名类型而变化。
- .RSA (PKCS7签名，SHA-256 + RSA)
- .DSA (PKCS7签名，DSA)

未列出的签名算法的数字签名文件必须位于 META-INF 目录下，并带有前缀 "SIG-"。相应的签名文件（.SF 文件）也必须有相同的前缀。

对于那些不支持外部签名数据的格式，文件应包含 .SF 文件的已签名副本。因此，某些数据可能会重复，验证者应该比较这两个文件。

支持外部数据的格式要么引用 .SF 文件，要么对其进行隐式引用的计算。

每个 .SF 文件可以有多个数字签名，但这些签名应当由同一个合法实体生成。

文件名扩展名可以是1到3个字母数字字符。无法识别的扩展名将被忽略。










### 清单和签名文件的注意事项

以下是适用于清单和签名文件的额外限制和规则列表：

#### 在解析之前：
- 如果文件的最后一个字符是EOF字符（代码26），则EOF被视为空白。将追加两个新行（一个用于那些不在最后一行末尾放置新行的编辑器，另一个是为了避免文法需要特别处理可能没有后续空行的最后一个条目）。

#### 属性：
- 对于所有部分的所有情况，不被理解的属性将被忽略。
- 属性名称不区分大小写。然而，生成清单和签名文件的程序应使用本规范中显示的大小写。
- 在一个部分内，属性名称不能重复。

#### 版本：
- `Manifest-Version` 和 `Signature-Version` 必须放在首位，并且必须完全按照所示的大小写（以便容易识别为特殊的字符串）。除此之外，主部分内的属性顺序并不重要。

#### 排序：
- 单个清单条目的顺序并不重要。
- 单个签名条目的顺序并不重要，除非要签名的摘要按此顺序排列。

#### 行长度：
- 任何行在其UTF8编码形式下不得超过72字节（不是字符）。如果初始行由于值的原因超过此长度，则应在额外的行上继续（每行以一个空格开始）。

#### 错误：
- 如果文件无法根据此规范进行解析，则应输出警告，并且不应信任任何签名。

#### 限制：
- 因为头部名称不能延续，所以头部名称的最大长度为70字节（名称后必须有一个冒号和一个空格）。
- NUL、CR和LF不能嵌入到头部值中，NUL、CR、LF和“:”不能嵌入到头部名称中。
- 实现应支持每个文件65535字节（不是字符）的头部值和65535个头部。尽管可能会耗尽内存，但不应该有低于这些值的硬编码限制。

#### 签名者：
- 技术上讲，不同的实体可能使用不同的签名算法共享一个签名文件，但这违反标准，额外的签名可能会被忽略。

#### 算法：
- 此标准并未强制或限制任何摘要或签名算法。
- 必须支持至少一种摘要算法。
- 如果摘要算法、签名算法或密钥大小受到`jdk.jar.disabledAlgorithms`安全属性的限制，则JAR将被视为未签名。请注意，`jdk.jar.disabledAlgorithms`安全属性当前由JDK参考实现使用，并不能保证其他实现会检查并使用它。 

通过遵循上述规则，可以确保清单和签名文件的一致性和正确性，从而保证数字签名的有效性和可靠性。













### JAR索引概述

自1.3版以来，为了优化网络应用程序（尤其是小程序）类加载器的类搜索过程，引入了JarIndex。最初，小程序类加载器使用简单的线性搜索算法在其内部搜索路径上搜索每个元素，这些元素由“ARCHIVE”标签或“Class-Path”主属性构建。类加载器会下载并打开其搜索路径上的每个元素，直到找到类或资源为止。如果尝试查找不存在的资源，则必须下载应用程序或小程序中的所有JAR文件。对于大型网络应用和小程序来说，这可能导致启动缓慢、响应迟缓以及网络带宽浪费。JarIndex机制收集在小程序中定义的所有JAR文件的内容，并将信息存储在小程序类路径上的第一个JAR文件中的索引文件中。在下载第一个JAR文件后，小程序类加载器将使用收集到的内容信息有效地下载JAR文件。

现有的jar工具得到了增强，可以检查一系列JAR文件并生成目录信息，指示哪些类和资源位于哪个JAR文件中。此目录信息存储在一个名为INDEX.LIST的简单文本文件中，该文件位于根JAR文件的META-INF目录下。当类加载器加载根JAR文件时，它读取INDEX.LIST文件并用它来构造一个从文件名和包名到JAR文件名列表的映射哈希表。为了查找类或资源，类加载器查询哈希表以找到合适的JAR文件并在必要时下载它。

### 索引文件规范

INDEX.LIST文件包含一个或多个部分，每部分由单个空白行分隔。每一部分定义了一个特定JAR文件的内容，有一个定义JAR文件路径名的头部，接着是包或文件名列表，每行一个。所有的JAR文件路径都是相对于根JAR文件的代码基。这些路径名以与当前扩展机制处理捆绑扩展相同的方式解析。UTF-8编码用于支持索引文件中文件或包名中的非ASCII字符。

### 规范格式

```
index file: version-info blankline section*
version-info: JarIndex-Version: version-number
version-number: digit+{.digit+}*
section: body blankline
body: header name*
header: char+.jar newline
name: char+ newline
char: any valid Unicode character except NULL, CR and LF
blankline: newline newline
newline: CR LF | LF | CR (not followed by LF)
digit: {0-9}
```

INDEX.LIST文件通过运行`jar -i`命令生成。有关更多详情，请参阅jar的手册页。

### 向后兼容性

新的类加载方案完全向后兼容基于当前扩展机制开发的应用程序。当类加载器加载第一个JAR文件并且在META-INF目录中找到了INDEX.LIST文件时，它会构建索引哈希表并使用新的加载方案进行扩展。否则，类加载器将仅使用原始的线性搜索算法。

### 服务提供者

#### 概述

META-INF/services目录下的文件是服务提供者配置文件。服务是一组知名接口和（通常是抽象的）类。服务提供者是对服务的具体实现。提供者中的类通常实现服务中定义的接口并继承其中的类。服务提供者可以通过作为扩展安装在Java平台的一个实现中，即放置于任何常规扩展目录中的JAR文件。提供者也可以通过将其添加到小程序或应用程序类路径或通过其他特定于平台的方法来提供。

服务由一个抽象类表示。给定服务的提供者包含一个或多个扩展此服务类并带有提供者特定数据和代码的具体类。这个提供者类通常不是整个提供者本身，而是一个代理，它包含足够的信息来决定提供者是否能够满足特定请求，以及可以在需要时创建实际提供者的代码。提供者类的细节往往高度依赖于具体的服务；没有单一的类或接口可以统一它们，因此也没有定义这样的类。这里强制要求的唯一条件是提供者类必须具有零参数构造函数，以便可以在查找期间实例化它们。

#### 提供者配置文件

服务提供者通过在资源目录META-INF/services中放置提供者配置文件来标识自己。文件名称应由抽象服务类的完全限定名组成。文件应包含一个换行符分隔的独特具体提供者类名列表。空格和制表符以及空行将被忽略。注释字符是'#'（0x23）；在每一行上，第一个注释字符之后的所有字符都将被忽略。文件必须使用UTF-8编码。










### 示例

假设我们有一个名为 `java.io.spi.CharCodec` 的服务类，它有两个抽象方法：

```java
public abstract CharEncoder getEncoder(String encodingName);
public abstract CharDecoder getDecoder(String encodingName);
```

每个方法返回一个适当的对象或如果无法转换给定编码则返回 null。典型的 `CharCodec` 提供者将支持不止一种编码。

如果 `sun.io.StandardCodec` 是 `CharCodec` 服务的一个提供者，那么它的 JAR 文件中会包含文件 `META-INF/services/java.io.spi.CharCodec`。这个文件将包含一行：

```
sun.io.StandardCodec    # Standard codecs for the platform
```

为了定位给定编码名称的编码器，内部 I/O 代码可能会这样做：

```java
CharEncoder getEncoder(String encodingName) {
    Iterator ps = Service.providers(CharCodec.class);
    while (ps.hasNext()) {
        CharCodec cc = (CharCodec)ps.next();
        CharEncoder ce = cc.getEncoder(encodingName);
        if (ce != null)
            return ce;
    }
    return null;
}
```

查找提供者的机制总是在调用者的安全上下文中执行。受信任的系统代码通常应该从特权安全上下文中调用此类中的方法。

### Class-Path 属性

应用程序的清单可以指定一个或多个相对 URL，指向它所需的其他库的 JAR 文件和目录。这些相对 URL 被视为相对于加载包含该应用的代码基。

应用程序（或者更广泛地说，JAR 文件）使用清单属性 `Class-Path` 来指定它所需的库的相对 URL。此属性列出了在主机 Java 虚拟机上找不到其他库实现时要搜索的 URL。这些相对 URL 可以包括任何应用程序或资源所需的库或资源的 JAR 文件和目录。不以斜杠 (/) 结尾的相对 URL 被假定为引用 JAR 文件。例如：

```
Class-Path: servlet.jar infobus.jar acme/beans.jar images/
```

在 JAR 文件的清单中最多可以指定一个 `Class-Path` 头。

目前出于安全原因，URL 必须是相对于 JAR 文件的代码基。因此，远程可选包将源自与应用程序相同的代码基。

每个相对 URL 都根据加载包含的应用程序或库的代码基进行解析。如果生成的 URL 无效或指向找不到的资源，则忽略它。

生成的 URL 用于通过在包含 JAR 文件的 URL 后立即插入这些 URL 来扩展应用程序、小程序或 Servlet 的类路径。任何重复的 URL 都会被省略。例如，给定以下类路径：

```
a.jar b.jar
```

假设 `b.jar` 包含以下 `Class-Path` 清单属性：

```
Class-Path: x.jar a.jar
```

结果，生成的应用程序类路径将是：

```
a.jar b.jar x.jar
```

如果 `x.jar` 有它自己的依赖项，那么这些依赖项将按照相同规则添加到每个后续 URL 中。在实际实现中，JAR 文件依赖关系是惰性处理的，因此只有在需要时才会打开 JAR 文件。









### 包密封

JAR文件和包可以选择性地进行密封，以确保版本内的一致性。当一个包被密封在JAR中时，这意味着该包中的所有类必须来自同一个JAR文件。否则，将抛出`SecurityException`。

- **包密封**：在一个JAR中指定的密封包意味着该包中定义的所有类都必须源自同一个JAR。这通过清单属性`Sealed`来指定，其值为true或false（大小写不敏感）。例如：

  ```
  Name: javax/servlet/internal/
  Sealed: true
  ```

  这表示`javax.servlet.internal`包是密封的，且该包中的所有类必须从相同的JAR文件加载。

  如果缺少此属性，则使用包含JAR文件的密封属性。

- **JAR密封**：整个JAR文件也可以通过相同的清单头部`Sealed`指定为密封，值同样为true或false。例如：

  ```
  Sealed: true
  ```

  这表示除非特定包在清单条目中用`Sealed`属性明确覆盖，否则这个归档中的所有包都是密封的。

  如果缺少此属性，为了向后兼容，默认假设JAR文件不是密封的。系统随后会默认检查包头信息以获取密封信息。

包密封对于安全性也很重要，因为它限制了仅允许来自同一JAR文件的包内的类访问包保护成员。

未命名的包是不可密封的，因此希望密封的类必须放置在它们自己的包中。

### API详情

- **java.util.jar包**：提供了处理JAR文件的功能。
  
- **参考**：
  - **java.security包**：提供了一系列安全框架相关的类和接口。
  - **java.util.zip包**：支持读写标准ZIP数据格式以及读写JAR文件的数据格式。

通过使用这些API和概念，开发者可以更好地控制JAR文件的安全性和完整性，从而增强应用程序的安全性。密封包有助于防止未经授权的代码插入到已知的、受信任的包中，确保只有特定来源的类才能对这些包进行扩展或修改。